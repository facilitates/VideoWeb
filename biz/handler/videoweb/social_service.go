// Code generated by hertz generator.

package videoweb

import (
	"context"
	"encoding/json"
	"fmt"
	"github.com/hertz-contrib/websocket"
	"log"
	"strconv"
	"time"
	"videoweb/biz/pack"
	"videoweb/dao"
	"videoweb/pkg/utils"

	"github.com/cloudwego/hertz/pkg/app"
	"github.com/cloudwego/hertz/pkg/protocol/consts"
	"videoweb/biz/model/videoweb"
)

// RelationAction .
// @router /relation/action [POST]
func RelationAction(ctx context.Context, c *app.RequestContext) {
	var err error
	var req videoweb.RelationActionRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}
	claim, _ := utils.ParseToken(string(c.GetHeader("Access-Token")))
	followingid, _ := strconv.ParseUint(req.ToUserID, 10, 64)
	var state int
	state, err = req.RelationAction(claim.ID, uint(followingid))
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
	} else {
		resp := pack.BuildRelationActionResp(state)
		c.JSON(200, resp)
	}
}

// FollowingList .
// @router /following/list [GET]
func FollowingList(ctx context.Context, c *app.RequestContext) {
	var err error
	var req videoweb.FollowingListRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}
	var followings []dao.UserDB
	var count int
	followerid, _ := strconv.ParseUint(req.UserID, 10, 64)
	followings, count, err = req.FollowingList(uint(followerid))
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
	}
	resp := pack.BuildFollowingList(followings, count, 1)
	c.JSON(consts.StatusOK, resp)
}

// FollowerList .
// @router /follower/list [GET]
func FollowerList(ctx context.Context, c *app.RequestContext) {
	var err error
	var req videoweb.FollowerListRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}
	var followers []dao.UserDB
	var total int
	userid, _ := strconv.ParseUint(req.UserID, 10, 64)
	followers, total, err = req.FollowerList(uint(userid))
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
	}
	resp := pack.BuildFollowingList(followers, total, 2)
	c.JSON(consts.StatusOK, resp)
}

// FriendsList .
// @router /friends/list [GET]
func FriendsList(ctx context.Context, c *app.RequestContext) {
	var err error
	var req videoweb.FriendsListRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}
	claim, err := utils.ParseToken(string(c.GetHeader("Access-Token")))
	friends, err := req.FriendList(claim.ID)
	var onlineFriends []dao.UserDB
	var count = 0
	for _, friend := range friends {
		exist, err := dao.Redisdb.SIsMember("user_online_state", friend.UserName).Result()
		if err != nil {
			resp := pack.BuildErrResp(400, err)
			c.JSON(200, resp)
		}
		if exist {
			onlineFriends = append(onlineFriends, friend)
			count++
		}
	}
	resp := pack.BuildFriendsListResp(onlineFriends, count)
	c.JSON(consts.StatusOK, resp)
}

func WebSocket(ctx context.Context, c *app.RequestContext) {
	claim, _ := utils.ParseToken(c.Query("Access-Token"))
	var upgrader = websocket.HertzUpgrader{
		ReadBufferSize:   1024,
		WriteBufferSize:  1024,
		HandshakeTimeout: 5 * time.Second,
		CheckOrigin: func(ctx *app.RequestContext) bool {
			return true
		},
	}
	userid := strconv.FormatUint(uint64(claim.ID), 10)
	uintUserid := claim.ID
	err := upgrader.Upgrade(c, func(conn *websocket.Conn) {
		for {
			mt, rawmessage, err := conn.ReadMessage()
			type Message struct {
				Type int             `json:"type"`
				Data json.RawMessage `json:"data"`
			}
			var message Message
			if err := json.Unmarshal(rawmessage, &message); err != nil {
				log.Println("Error unmarshalling JSON:", err)
				return
			}
			var msg interface{}
			switch message.Type {
			case 1:
				msg = new(videoweb.Type1)
			case 2:
				msg = new(videoweb.Type2)
			case 3:
				msg = new(videoweb.Type2)
			case 4:
				msg = new(videoweb.Type1)
			case 5:
				msg = new(videoweb.Type2)
			}
			if err := json.Unmarshal(message.Data, msg); err != nil {
				log.Println("Error unmarshalling payload:", err)
				continue
			}
			switch message.Type {
			case 1:
				receiverid, _ := strconv.ParseUint(msg.(*videoweb.Type1).ID, 10, 64)
				chatkey := userid + "to" + msg.(*videoweb.Type1).ID
				fmt.Println(chatkey)
				stringtime := strconv.FormatInt(time.Now().Unix(), 10)
				var chat = dao.ChatDB{
					Content:    msg.(*videoweb.Type1).Content,
					SenderId:   uintUserid,
					ReceiverId: uint(receiverid),
					Time:       stringtime,
				}
				err = videoweb.SendMessageToUser(chat, chatkey)
				if err != nil {
					log.Println(err)
					err = conn.WriteMessage(mt, []byte("发送失败"))
				} else {
					err = conn.WriteMessage(mt, []byte("发送成功"))
				}
			case 2:
				var chathistorys []dao.ChatDB
				id, _ := strconv.ParseUint(msg.(*videoweb.Type2).ID, 10, 64)
				chathistorys, err = videoweb.ChatHistoryWithUser(uint(id))
				type response struct {
					Time    string
					Content string
				}
				var packed []response
				for _, chathistory := range chathistorys {
					packed = append(packed, response{
						Time:    chathistory.Time,
						Content: chathistory.Content,
					})
				}
				msgsJSON, err := json.Marshal(packed)
				if err != nil {
					log.Println("序列化消息失败：", err)
					return
				}
				err = conn.WriteMessage(mt, msgsJSON)
			case 3:
				//	type response struct {
				//		Time    string
				//		Content string
				//	}
				var UnrecHistory []dao.ChatDB
				chatkey := msg.(*videoweb.Type2).ID + "to" + userid
				UnrecHistory, err = videoweb.SearchUnrecHistory(chatkey)
				if err != nil {
					log.Println(err)
				}
				var packedUnrec []dao.ChatDB
				start := int(msg.(*videoweb.Type2).Pagesize * (msg.(*videoweb.Type2).Pagenum - 1))
				for i, a := range UnrecHistory {
					if i >= start {
						uintsender, _ := strconv.ParseUint(msg.(*videoweb.Type2).ID, 10, 64)
						a.SenderId = uint(uintsender)
						a.ReceiverId = claim.ID
						packedUnrec = append(packedUnrec, a)
					}
				}
				err := videoweb.SaveUnrecHistory(packedUnrec)
				if err != nil {
					log.Println(err)
				}
				msgsJSON, err := json.Marshal(UnrecHistory)
				if err != nil {
					log.Println("序列化消息失败：", err)
					return
				}
				err = conn.WriteMessage(mt, msgsJSON)
			case 4:
				groupkey := "group:" + msg.(*videoweb.Type1).ID
				err = videoweb.SendMessageToGroup(groupkey, msg.(*videoweb.Type1).Content, claim.ID)
				err = conn.WriteMessage(mt, []byte("发送成功"))
				//case 5:
				//	err = videoweb.ChatHistoryWithGroup()
			}
			if err != nil {
				resp := pack.BuildErrResp(400, err)
				c.JSON(200, resp)
				break
			}
		}
	})
	if err != nil {
		log.Print("upgrade:", err)
		return
	}
}
